<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 02 Beyn&#39;s global eigenvalue solver ¬∑ WavesAndEigenvalues</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WavesAndEigenvalues</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="Mesh.html">Mesh</a></li><li><a class="tocitem" href="Helmholtz.html">Helmholtz</a></li><li><a class="tocitem" href="NLEVP.html">NLEVP</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="load_mesh.html">How to load a mesh?</a></li><li><a class="tocitem" href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a></li><li class="is-active"><a class="tocitem" href="tutorial_02_gloabal_eigenvalue_solver.html">Tutorial 02 Beyn&#39;s global eigenvalue solver</a><ul class="internal"><li><a class="tocitem" href="#Introduction-1"><span>Introduction</span></a></li><li><a class="tocitem" href="#Model-set-up.-1"><span>Model set up.</span></a></li><li><a class="tocitem" href="#Number-of-eigenvalues-1"><span>Number of eigenvalues</span></a></li><li><a class="tocitem" href="#Qudrature-points-1"><span>Qudrature points</span></a></li><li><a class="tocitem" href="#Test-singular-values-1"><span>Test singular values</span></a></li><li><a class="tocitem" href="#Test-the-position-of-the-eigenvalues-1"><span>Test the position of the eigenvalues</span></a></li><li><a class="tocitem" href="#Toggle-the-progress-bar-1"><span>Toggle the progress bar</span></a></li></ul></li><li><a class="tocitem" href="tutorial_03_local_eigenvalue_solver.html">Tutorial 03 Lancaster&#39;s local eigenvalue solver</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="tutorial_02_gloabal_eigenvalue_solver.html">Tutorial 02 Beyn&#39;s global eigenvalue solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial_02_gloabal_eigenvalue_solver.html">Tutorial 02 Beyn&#39;s global eigenvalue solver</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/master/docs/src/tutorial_02_gloabal_eigenvalue_solver.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-02-Beyn&#39;s-global-eigenvalue-solver-1"><a class="docs-heading-anchor" href="#Tutorial-02-Beyn&#39;s-global-eigenvalue-solver-1">Tutorial 02 Beyn&#39;s global eigenvalue solver</a><a class="docs-heading-anchor-permalink" href="#Tutorial-02-Beyn&#39;s-global-eigenvalue-solver-1" title="Permalink"></a></h1><h2 id="Introduction-1"><a class="docs-heading-anchor" href="#Introduction-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#Introduction-1" title="Permalink"></a></h2><p>In Tutorial 01 you learnt the basics of the Helmholtz solver. This tutorial will make you more familiar with the global eigenvalue solver. The solver implements an algorithm invented by W.-J. Beyn in [1]. The implementation closely follows [2].</p><h3 id="References-1"><a class="docs-heading-anchor" href="#References-1">References</a><a class="docs-heading-anchor-permalink" href="#References-1" title="Permalink"></a></h3><p>[1] W.-J. Beyn, An integral method for solving nonlinear eigenvalue problems, Linear Algebra and its Applications, 2012, 436(10), p.3839-3863, https://doi.org/10.1016/j.laa.2011.03.030 [2] P.E. Buschmann, G.A. Mensah, J.P. Moeck, Solution of Thermoacoustic Eigenvalue Problems with a Non-Iterative Method, J. Eng. Gas Turbines Power, Mar 2020, 142(3): 031022 (11 pages) https://doi.org/10.1115/1.4045076</p><h2 id="Model-set-up.-1"><a class="docs-heading-anchor" href="#Model-set-up.-1">Model set up.</a><a class="docs-heading-anchor-permalink" href="#Model-set-up.-1" title="Permalink"></a></h2><p>The model is the same Rijke tube configuration as in Tutorial 01:</p><pre><code class="language-julia">using WavesAndEigenvalues.Helmholtz
mesh=Mesh(&quot;Rijke_mm.msh&quot;,scale=0.001) #load mesh
dscrp=Dict() #initialize model discreptor
dscrp[&quot;Interior&quot;]=(:interior, ()) #define resonant cavity
dscrp[&quot;Outlet&quot;]=(:admittance, (:Y,1E15)) #specify outlet BC
Œ≥=1.4 #ratio of specific heats
œÅ=1.225 #density at the reference location upstream to the flame in kg/m^3
Tu=300.0    #K unburnt gas temperature
Tb=1200.0    #K burnt gas temperature
P0=101325.0 # ambient pressure in Pa
A=pi*0.025^2 # cross sectional area of the tube
Q02U0=P0*(Tb/Tu-1)*A*Œ≥/(Œ≥-1) #the ratio of mean heat release to mean velocity Q02U0
x_ref=[0.0; 0.0; -0.00101] #reference point
n_ref=[0.0; 0.0; 1.00] #directional unit vector of reference velocity
n=0.01 #interaction index
œÑ=0.001 #time delay
dscrp[&quot;Flame&quot;]=(:flame,(Œ≥,œÅ,Q02U0,x_ref,n_ref,:n,:œÑ,n,œÑ)) #flame dynamics
R=287.05 # J/(kg*K) specific gas constant (air)
speedofsound(x,y,z) = z&lt;0. ? sqrt(Œ≥*R*Tu) : sqrt(Œ≥*R*Tb)
c=generate_field(mesh,speedofsound)
L=discretize(mesh,dscrp,c)</code></pre><pre><code class="language-none">1006√ó1006 dimensional operator family: 

œâ^2*M+K+n*exp(-iœâœÑ)*Q+œâ*Y*C

Parameters
----------
n	0.01 + 0.0im
Œª	Inf + 0.0im
œâ	0.0 + 0.0im
œÑ	0.001 + 0.0im
Y	1.0e15 + 0.0im
</code></pre><p>The global eigenvalue solver has a range of parameters. Mandatory, are only the linear operator family <code>L</code> you like to solve and the contour <code>Œì</code>.</p><p>The contour is specified as a list of complex numbers. Each of which defining a vertex of the polygon you want to scan for eigenvalues. In Tutorial 01 we specified the contour as rectangle by</p><pre><code class="language-julia">Œì=[150.0+5.0im, 150.0-5.0im, 1000.0-5.0im, 1000.0+5.0im].*2*pi</code></pre><pre><code class="language-none">4-element Array{Complex{Float64},1}:
 942.4777960769379 + 31.41592653589793im
 942.4777960769379 - 31.41592653589793im
 6283.185307179586 - 31.41592653589793im
 6283.185307179586 + 31.41592653589793im</code></pre><p>The verteces are traversed in the order you specify them. However, the direction does not matter, meaning that equivalently you can specify <code>Œì</code> as:</p><pre><code class="language-julia">Œì=[1000.0+5.0im, 1000.0-5.0im, 150.0-5.0im, 150.0+5.0im]</code></pre><pre><code class="language-none">4-element Array{Complex{Float64},1}:
 1000.0 + 5.0im
 1000.0 - 5.0im
  150.0 - 5.0im
  150.0 + 5.0im</code></pre><p>Note that you should <em>not</em> specify the first point as the last point. This will be automatically done for you by the solver.</p><p>Again, Œì is a polygon, so, e.g., specifying only three points will make the search region a triangle. And to get curved regions you just approximate them by a lot of vertices. For instance, this polygon is a good approximation of a circle.</p><pre><code class="language-julia">radius=10
center_point=100
Œì_circle=radius.*[cos(Œ±)+sin(Œ±)*1.0im for Œ±=0:2*pi/1000:(2*pi-2*pi/1000)].+center_point</code></pre><pre><code class="language-none">1000-element Array{Complex{Float64},1}:
              110.0 + 0.0im
 109.99980260856137 + 0.06283143965558952im
 109.99921044203816 + 0.1256603988335261im
  109.9982235238081 + 0.18848439715408175im
   109.996841892833 + 0.2513009544333748im
 109.99506560365731 + 0.3141075907812829im
  109.9928947264059 + 0.3769018266993454im
 109.99032934678125 + 0.43968118317864907im
 109.98736956606018 + 0.5024431817976955im
 109.98401550108974 + 0.5651853448202453im
                    ‚ãÆ
 109.98401550108974 - 0.5651853448202481im
 109.98736956606018 - 0.5024431817976934im
 109.99032934678125 - 0.43968118317865074im
  109.9928947264059 - 0.37690182669934214im
 109.99506560365731 - 0.3141075907812836im
   109.996841892833 - 0.25130095443337047im
  109.9982235238081 - 0.18848439715408138im
 109.99921044203816 - 0.1256603988335207im
 109.99980260856137 - 0.06283143965558806im</code></pre><p>Note that your contour does not need to be convex!</p><h2 id="Number-of-eigenvalues-1"><a class="docs-heading-anchor" href="#Number-of-eigenvalues-1">Number of eigenvalues</a><a class="docs-heading-anchor-permalink" href="#Number-of-eigenvalues-1" title="Permalink"></a></h2><p>Beyn&#39;s algorithm needs an initial guess on how many eigenvalues <code>l</code> you expect inside your contour. Per default this is <code>l=5</code>. If this guess is less than the actual eigenvalues. The algorithms will miserably fail to compute any eigenvalue inside your contour correctly. You may, therefore, choose a large number for <code>l</code> to be on the save site. However, this will dramatically increase your computation time.</p><p>There are several strategies to deal with this problem and each of which might be well suited in a certain situation:</p><ol><li>Split your domain in several smaller domains. This reduces the potential</li></ol><p>number of eigenvalues in each of the subdomains.</p><ol><li>Just repeatedly rerun the solver with increasing values of <code>l</code> until</li></ol><p>the found eigenvalues do not change anymore.</p><h2 id="Qudrature-points-1"><a class="docs-heading-anchor" href="#Qudrature-points-1">Qudrature points</a><a class="docs-heading-anchor-permalink" href="#Qudrature-points-1" title="Permalink"></a></h2><p>As Beyn&#39;s algorithm is based on contour integration a numerical quadrature method is performed under the hood. More precisely, the code performs a Gauss-Legendre integration on each of the edges of the Polygon <code>Œì</code>. The number of quadrature points for each of these integrations is <code>N=32</code> per default. But you can specify it as an optional parameter when calling the solver. For instance as the circular contour is already discretized by 1000 points, it is not necessary to utilize <code>N=16</code> quadrature points on each of the edges. Let&#39;s say <code>N=4</code> should be fine. Then, you would call the solver like</p><pre><code class="language-julia">Œ©,P=beyn(L,Œì_circle,N=4,output=true)</code></pre><pre><code class="language-none">(Complex{Float64}[], Array{Complex{Float64}}(undef,1006,0))</code></pre><h2 id="Test-singular-values-1"><a class="docs-heading-anchor" href="#Test-singular-values-1">Test singular values</a><a class="docs-heading-anchor-permalink" href="#Test-singular-values-1" title="Permalink"></a></h2><p>One step in Beyn&#39;s algorithm requires a singular value decomposition. Non-zero singular values and singular vectors associated with these are meant to be disregarded. Unfortunately, on a computer zero could also mean a very small number, and <em>small</em> here is problem dependend. The code will disregard any singular value <code>œÉ&lt;tol</code> where <code>tol == 0.0</code> Per default. This means, that per default only singular values that are exactly 0 will be disregraded. It is very unlikely that this will be the case for any singular value. You may specify your own threshold by the optional key-word argument <code>tol</code></p><pre><code class="language-julia">Œ©,P=beyn(L,Œì, tol=1E-10)</code></pre><pre><code class="language-none">(Complex{Float64}[], Array{Complex{Float64}}(undef,1006,0))</code></pre><p>but this is rather an option for experts. Even the authors of the code do not know a systematic way of well defining this threshold for given configuration.</p><h2 id="Test-the-position-of-the-eigenvalues-1"><a class="docs-heading-anchor" href="#Test-the-position-of-the-eigenvalues-1">Test the position of the eigenvalues</a><a class="docs-heading-anchor-permalink" href="#Test-the-position-of-the-eigenvalues-1" title="Permalink"></a></h2><p>Because there could be a lot of spurious eigenvalues as there is no correct implementation of the singular value test. A very simple test to chek whether your eigenvalues are correct is to see whether they are inside your contour <code>Œì</code>. This test is performed per default, but you can disable it using the keyword <code>pos_test</code>.</p><pre><code class="language-julia">Œ©,P=beyn(L,Œì, pos_test=false)</code></pre><pre><code class="language-none">(Complex{Float64}[225.9839164374904 - 123.53416646407038im, 272.1973200985744 + 107.42135485599285im, 515.9746699146607 - 119.83761955678037im, 517.0430033957158 + 34.27144266122359im, 606.6806094812961 - 53.44612212087221im], Complex{Float64}[-0.004161310144188599 + 0.0284494057743415im -0.0075457838802195365 + 0.019156665156701447im ‚Ä¶ -0.012064414231151937 + 0.01839698181597222im -0.010677493179445472 + 0.012283577067099375im; -0.004475660997771335 + 0.02847633685911769im -0.007397658638503855 + 0.018988128894963822im ‚Ä¶ -0.010497832136359587 + 0.01733761978921902im -0.01043082472154314 + 0.011719355405345137im; ‚Ä¶ ; -0.008528065939335496 + 0.027654159638150235im -0.010975925878145712 + 0.01977722597552062im ‚Ä¶ -0.014607376635858331 + 0.022882510649576724im -0.009953336915537136 + 0.017379785519447452im; -0.0313949351486993 + 0.035652752690987735im -0.02992731482244764 + 0.04438656884275181im ‚Ä¶ -0.024918364273574092 + 0.04326354673119699im -0.034184363763374824 + 0.0512758140292902im])</code></pre><p>Note, that if you disable the position test and do not specify a threshold for the singular values, you will always be returned with <code>l</code> eigenvalues by Beyn&#39;s algorithm. (And sometimes even eigenvalues that are outside of your contour are fairly correct... )</p><h2 id="Toggle-the-progress-bar-1"><a class="docs-heading-anchor" href="#Toggle-the-progress-bar-1">Toggle the progress bar</a><a class="docs-heading-anchor-permalink" href="#Toggle-the-progress-bar-1" title="Permalink"></a></h2><p>Especially when searching for many eigenvalues, in large domains the algorithm may take some time to finish. You can, therefore, optionally display a progress bar together with an estimate of how long it will take for the routine to finish. This is done using the optional keyword <code>output</code>.</p><pre><code class="language-julia">Œ©,P=beyn(L,Œì, output=true)

# TODO Caveats</code></pre><pre><code class="language-none">Beyn...  48%|‚ñà‚ñà‚ñà‚ñà‚ñá     |  ETA: 0:00:01[KBeyn...  98%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñá|  ETA: 0:00:00[KBeyn... 100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| Time: 0:00:01[K</code></pre><ul><li>contours close to eigenvalues</li><li>refine your solutions using householder</li><li>mention degeneracy</li></ul><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorial_01_rijke_tube.html">¬´ Tutorial 01 Rijke Tube</a><a class="docs-footer-nextpage" href="tutorial_03_local_eigenvalue_solver.html">Tutorial 03 Lancaster&#39;s local eigenvalue solver ¬ª</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 8 June 2020 17:06">Monday 8 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
